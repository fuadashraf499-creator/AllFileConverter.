const express = require('express');
const multer = require('multer');
const cors = require('cors');
const fs = require('fs-extra');
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const { v4: uuidv4 } = require('uuid');
const winston = require('winston');

// Configure Winston logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'allfileconverter-backend' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

// Create logs directory
fs.ensureDirSync(path.join(__dirname, 'logs'));

const app = express();
const PORT = process.env.PORT || 3000;

// Security middleware
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  next();
});

// CORS configuration
app.use(cors({
  origin: process.env.FRONTEND_URL || '*',
  methods: ['GET', 'POST'],
  allowedHeaders: ['Content-Type'],
  maxAge: 86400 // 24 hours
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Create uploads directory
const uploadsDir = path.join(__dirname, 'uploads');
const outputDir = path.join(__dirname, 'output');
fs.ensureDirSync(uploadsDir);
fs.ensureDirSync(outputDir);

// Request logging middleware (placed before routes)
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info('Request completed', {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });
  });
  next();
});

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${uuidv4()}-${file.originalname}`;
    cb(null, uniqueName);
  }
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 100 * 1024 * 1024 } // 100MB limit
});

// Tool paths
const tools = {
  ffmpeg: 'ffmpeg',
  pandoc: 'pandoc',
  pdftk: 'pdftk',
  ghostscript: 'gs',
  libreoffice: 'libreoffice',
  handbrake: 'HandBrakeCLI',
  imagemagick: 'convert',
  poppler: 'pdftoppm'
};

// Health check endpoint
app.get('/api/health', (req, res) => {
  const healthData = {
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    version: '1.0.0'
  };
  logger.info('Health check requested', { ip: req.ip, userAgent: req.get('User-Agent') });
  res.json(healthData);
});

// Get supported formats
app.get('/api/convert/formats', (req, res) => {
  const formats = {
    document: ['pdf', 'docx', 'doc', 'odt', 'rtf', 'txt', 'html'],
    image: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp', 'svg'],
    video: ['mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv', 'webm'],
    audio: ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'],
    archive: ['zip', 'rar', '7z', 'tar', 'gz'],
    cad: ['dwg', 'dxf', 'step', 'iges'],
    '3d': ['stl', 'obj', 'fbx', 'dae', 'ply']
  };
  res.json(formats);
});

// Convert file endpoint
app.post('/api/convert', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const { outputFormat } = req.body;
    if (!outputFormat) {
      return res.status(400).json({ error: 'Output format not specified' });
    }

    // Validate output format
    const allowedFormats = ['pdf', 'docx', 'doc', 'odt', 'rtf', 'txt', 'html', 'jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp', 'mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv', 'webm', 'mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'];
    if (!allowedFormats.includes(outputFormat.toLowerCase())) {
      return res.status(400).json({ error: 'Invalid output format' });
    }

    const inputFile = req.file.path;
    const inputExt = path.extname(req.file.originalname).toLowerCase().slice(1);
    const outputFileName = `${path.parse(req.file.filename).name}.${outputFormat}`;
    const outputFile = path.join(outputDir, outputFileName);

    // Validate file size (100MB limit)
    if (req.file.size > 100 * 1024 * 1024) {
      fs.removeSync(inputFile);
      return res.status(400).json({ error: 'File size exceeds 100MB limit' });
    }

    // Determine conversion command based on file types
    let command = '';

    // Document conversions
    if (['pdf', 'docx', 'doc', 'odt', 'rtf', 'txt', 'html'].includes(inputExt) &&
      ['pdf', 'docx', 'doc', 'odt', 'rtf', 'txt', 'html'].includes(outputFormat)) {
      if (inputExt === 'pdf' && outputFormat === 'txt') {
        command = `pdftotext "${inputFile}" "${outputFile}"`;
      } else {
        command = `pandoc "${inputFile}" -o "${outputFile}"`;
      }
    }
    // PDF to Image conversions
    else if (inputExt === 'pdf' && ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp'].includes(outputFormat)) {
      // Use ImageMagick to convert PDF to image (first page only)
      const density = outputFormat === 'jpg' || outputFormat === 'jpeg' ? '300' : '150';
      command = `convert -density ${density} "${inputFile}[0]" -quality 90 "${outputFile}"`;
    }
    // Image conversions
    else if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp'].includes(inputExt) &&
      ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp'].includes(outputFormat)) {
      command = `convert "${inputFile}" "${outputFile}"`;
    }
    // Video conversions
    else if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv', 'webm'].includes(inputExt) &&
      ['mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv', 'webm'].includes(outputFormat)) {
      command = `ffmpeg -i "${inputFile}" "${outputFile}"`;
    }
    // Audio conversions
    else if (['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'].includes(inputExt) &&
      ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'].includes(outputFormat)) {
      command = `ffmpeg -i "${inputFile}" "${outputFile}"`;
    }
    // PDF operations
    else if (inputExt === 'pdf' && outputFormat === 'pdf') {
      command = `pdftk "${inputFile}" output "${outputFile}" compress`;
    }
    else {
      return res.status(400).json({ error: `Conversion from ${inputExt} to ${outputFormat} not supported` });
    }

    // Execute conversion command with proper async handling
    const { promisify } = require('util');
    const execAsync = promisify(exec);

    try {
      logger.info('Starting file conversion', {
        inputFile: req.file.originalname,
        inputFormat: inputExt,
        outputFormat: outputFormat,
        fileSize: req.file.size,
        command: command
      });

      const { stdout, stderr } = await execAsync(command, { timeout: 300000 }); // 5 minute timeout

      // Check if output file was created
      if (!fs.existsSync(outputFile)) {
        throw new Error('Conversion failed - output file not created');
      }

      logger.info('Conversion completed successfully', {
        inputFile: req.file.originalname,
        outputFile: outputFileName,
        outputSize: fs.statSync(outputFile).size
      });

      // Send the converted file
      res.download(outputFile, outputFileName, (err) => {
        if (err) {
          console.error('Download error:', err);
        }
        // Clean up files after download
        setTimeout(() => {
          try {
            fs.removeSync(inputFile);
            fs.removeSync(outputFile);
          } catch (cleanupError) {
            console.error('Cleanup error:', cleanupError);
          }
        }, 5000);
      });

    } catch (conversionError) {
      logger.error('Conversion failed', {
        error: conversionError.message,
        inputFile: req.file.originalname,
        inputFormat: inputExt,
        outputFormat: outputFormat,
        stack: conversionError.stack
      });

      // Clean up input file on error
      try {
        fs.removeSync(inputFile);
      } catch (cleanupError) {
        logger.error('Cleanup error after conversion failure', { error: cleanupError.message });
      }

      return res.status(500).json({
        error: 'Conversion failed',
        details: conversionError.message
      });
    }

  } catch (error) {
    logger.error('Server error in conversion endpoint', {
      error: error.message,
      stack: error.stack,
      file: req.file ? req.file.originalname : 'none'
    });

    // Clean up uploaded file if it exists
    if (req.file && req.file.path) {
      try {
        fs.removeSync(req.file.path);
      } catch (cleanupError) {
        logger.error('Cleanup error after server error', { error: cleanupError.message });
      }
    }

    res.status(500).json({ error: 'Internal server error' });
  }
});

// Tool status endpoint
app.get('/api/tools', async (req, res) => {
  try {
    const { promisify } = require('util');
    const execAsync = promisify(exec);
    const toolStatus = {};

    const toolChecks = Object.keys(tools).map(async (tool) => {
      try {
        const { stdout } = await execAsync(`${tools[tool]} --version`, { timeout: 5000 });
        toolStatus[tool] = {
          available: true,
          version: stdout.split('\n')[0]
        };
      } catch (error) {
        toolStatus[tool] = {
          available: false,
          version: 'Not found'
        };
      }
    });

    await Promise.all(toolChecks);
    res.json(toolStatus);
  } catch (error) {
    console.error('Tools check error:', error);
    res.status(500).json({ error: 'Failed to check tool status' });
  }
});

// Request logging middleware (moved before routes)
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info('Request completed', {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });
  });
  next();
});

// Start server
console.log("ðŸš€ Server starting on port 5002...");
app.listen(PORT, '0.0.0.0', () => {
  logger.info('AllFileConverter Backend started', {
    port: PORT,
    environment: process.env.NODE_ENV || 'development',
    nodeVersion: process.version
  });
  console.log(`ðŸš€ AllFileConverter Backend running on port ${PORT}`);
  console.log(`ðŸ“‹ Health check: http://localhost:${PORT}/api/health`);
  console.log(`ðŸ”§ Tools status: http://localhost:${PORT}/api/tools`);
  console.log(`ðŸ“ Conversion API: http://localhost:${PORT}/api/convert`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('ðŸ›‘ Received SIGTERM, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('ðŸ›‘ Received SIGINT, shutting down gracefully');
  process.exit(0);
});
